#!/usr/bin/ruby

###
### kwartz -- a template system which can separate presentation logic from template
###
### Copyright (C) 2004 kuwata-lab
### All rights reserved.
### author::  kwa(at)kuwata-lab.com
### id::      $Id$d
###
### This project is subsidized by Exploratory Software Project of IPA
### (Information-Technology Promotion Agency Japan).
### See http://www.ipa.go.jp/about/english/index.html for IPA.
###
### This program is free software; you can redistribute it and/or
### modify it under the terms of the GNU General Public License
### as published by the Free Software Foundation; either version 2
### of the License, or (at your option) any later version.
###
### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this program; if not, write to the Free Software
### Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

require 'kwartz'

module Kwartz

   class CommandOptionError < KwartzError
      def initialize(message='')
	 super(message)
      end
   end


   class MainCommand

      VERSION     = ('$Revision$' =~ /\d+(?:\.\d+)+/ && $&)
      LAST_UPDATE = ('$Date$' =~ /\d+[-\/]\d+[-\/]\d+/ && $&)

      def initialize(argv=ARGV)
	 @argv = ARGV
	 @command = File::basename($0)
	 @options    = {}
	 @properties = {}
      end


      def main(argv=ARGV)
	 parse_argv()
	 
	 flag_exit = false
	 if @options['-v']
	    print "#{VERSION} (#{LAST_UPDAT})\n"
	    flag_exit = true
	 end
	 if @options['-h']
	    print usage()
	    flag_exit = true
	 end
	 if flag_exit
	    return 0
	 end
	 
	 action = @options['-a'] || 'compile'
	 case action
	 when 'compile', 'convert', 'parse', 'translate', 'scan'
	    # nothing
	 else
	    raise CommandOptionError.new("#{action}: invalid action.")
	 end

	 if @options['-s'] || @options['-e']
	    @properties[:escape] = true
	 end
	 
	 lang = @options['-l'] || 'ruby'
	 
	 plogic_filenames = @options['-p'] ? @options['-p'].split(/,/) : []
	 plogic_block = nil
	 plogic_filenames.each do |filename|
	    unless test(?f, filename)
	       raise CommandOptionError.new("'#{filename}': not found.")
	    end
	    File.open(filename) do |file|
	       plogic = file.read()
	       @properties[:filename] = filename
	       parser = Parser.new(plogic, @properties)
	       block = parser.parse()
	       plogic_block  = plogic_block ? plogic_block.merge(block) : block
	    end
	 end
	 
	 output = ''
	 if @argv.empty?
	    input = ARGF.read()
	    output = do_action(action, input, plogic_block, lang, @properties)
	 else
	    @argv.each do |filename|
	       unless test(?f, filename)
		  raise CommandOptionError.new("'#{filename}': not found.")
	       end
	       File.open(filename) do |file|
		  input = file.read()
		  @properties[:filename] = filename
		  output << do_action(action, input, plogic_block, lang, @properties)
	       end
	    end
	 end
	 print output
	 return 0
      end

      
      private

      
      def usage()
	 s = <<END
Usage: #{@command} [..options..] file1 [file2...]
  -h, --help : help
  -v         : version
  -a action  : compile/parse/translate/convert (default 'compile')
  -l lang    : ruby/ruby2/eruby/erb/php/jsp (default 'ruby')
  -p file    : presentation logic filename
  -s         : sanitize (identical to '-e')
  -e         : escape
  --odd_value=value      : odd  value in FOREACH or LIST (default "'odd'")
  --even_value=value     : even value in FOREACH or LIST (default "'even'")
  --attr_name=attr       : use attribute name as marking (default 'kd')
END
	 return s
      end

      
      def parse_argv()
	 argv = @argv
	 while !argv.empty? && argv[0][0] == ?-
	    opt = argv.shift
	    case opt
	    when '-h', '-v', '-s', '-e'
	       @options[opt] = true
	    when '-a', '-l', '-p'
	       if argv.empty?
		  raise CommandOptionError.new("'#{opt}' requires argument.")
	       end
	       @options[opt] = argv.shift
	    when '--help'
	       @options['-h'] = true
	    when /^--([-\w]+)(?:=(.*))?$/
	       value = $2
	       name  = $1.gsub(/-/, '_')
	       case value
	       when 'true', 'yes'
		  value = true
	       when 'false', 'no'
		  value = false
	       when 'null', 'nil'
		  value = nil
	       when /^\d+$/
		  value = value.to_i
	       when /^\d+\.\d+$/
		  value = value.to_f
	       when /^\/.*\/$/
		  value = eval value
	       when /^'.*'$/
		  value = eval value
	       when /^".*"$/
		  value = eval value
	       end
	       @properties[name.intern] = value
	    else
	       raise CommandOptionError.new("'#{opt}': invalid option.")
	    end
	 end
      end


      def do_action(action, input, plogic_block, lang, properties)
	 case action
	 when 'convert'
	    converter = Converter.new(input, properties)
	    output = converter.convert()
	 when 'scan'
	    scanner = Scanner.new(input, properties)
	    output = scanner.scan_all()
	 else
	    raise CommandOptionError.new("#{action}: not implemented yet.")
	 end
	 return output
      end

   end

end


if __FILE__ == $0
   begin
      main_command = Kwartz::MainCommand.new(ARGV)
      main_command.main()
   rescue Kwartz::KwartzError => ex
      $stderr.print ex.message, "\n"
      exit 1
   end
end
