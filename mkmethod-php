#!/usr/local/bin/php -q
<?php
// vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4:

//
// mkmethod-php -- compile template and define a method to print it.
//
// $Id$
//
// Copyright (C) 2004 kuwata-lab All rights reserved.
//


require('Kwartz.php');


function usage($command) {
    $usage = <<<END
Usage: {$command} [-svh] [-p file] [-M module] [-m method] file.html
  -h, --help         : print help and exit
  -v                 : print version and exit
  -p file            : presentation logic file
  -c class           : class name (default none)
  -m method          : method name (default 'expand_' + file)
  -a arg1,arg2,...   : method arguments (default none)
  -s, -e             : sanitize(escape) (equals to '--escape=true')
  --key=value        : properties for kwartz-php

END;
    return $usage;
}


function version() {
    $filename   = basename(__FILE__);
    $id_str     = '$Id$';
    $revision   = '$Rev';
    $lastupdate = '$Date';
    if (preg_match('/\d+/', $revision, $m = array())) {
        $revision = $m[0];
    }
    if (preg_match('/\d+[-\/]\d\d[-\/]\d\d\s+\d\d:\d\d:\d\d/', $revision, $m = array())) {
        $lastupdate = $m[0];
    }
    $version = "{$filename}: {$revision} ({$lastupdate})\n";
    return $version;
}


class KwartzCommandOptionError extends KwartzException {
    function __construct($message) {
        parent::__construct($message);
    }
}


function parse_args(&$args=NULL, $noarg=NULL, $argrequired=NULL, $argoptional=NULL) {
    if (count($args) == 0) {
        return NULL;
    }
    
    $options = array();		// hash
    $toppings = array();	// hash
    $error_msg = NULL;
    while (count($args) > 0 && $args[0][0] == '-') {
        $optstr = substr(array_shift($args), 1);
        
        // parse toppings
        if ($optstr[0] == '-') {
            if (preg_match('/^-([-\w]+)(?:=(.*))?/', $optstr, $m = array())) {
                $key   = $m[1];
                $value = $m[2];
                if ($value === NULL) {
                    $value = TRUE;
                } else {
                    switch ($value) {
                      case 'true':  $value = TRUE;   break;
                      case 'false': $value = FALSE;  break;
                      case 'null':  $value = NULL;   break;
                      default:
                    }
                }
                $key = preg_replace('/_/', '-', $key);
                $toppings[$key] = $value;
            } else {
                $error_msg = "'-${optstr}': invalid option.";
                throw new KwartzCommandOptionError($error_msg);
            }
            continue;
        }
        
        // parse command options
        while ($optstr) {
            $optch = $optstr[0];
            $optstr = substr($optstr, 1);
            if (strpos($noarg, $optch) !== FALSE) {
                $options[$optch] = TRUE;
            } elseif (strpos($argrequired, $optch) !== FALSE) {
                $arg = $optstr ? $optstr : array_shift($args);
                if ($arg === NULL) {
                    $error_msg = "-${optch}: argument required.";
                } else {
                    $options[$optch] = $arg;
                }
                break;
            } elseif (strpos($argoptional, $optch) !== FALSE) {
                $options[$optch] = $optstr ? $optstr : TRUE;
                break;
            } else {
                $error_msg = "'-${optch}${optstr}': invalid option.";
                break;
            }
        }
        if ($error_msg) {
            throw new KwartzCommandOptionError($error_msg);
        }
    }
    
    return array($options, $toppings);
}


function array_value($key, &$array) {
    return array_key_exists($key, $array) ? $array[$key] : NULL;
}


function compile(&$pdata, &$plogic, &$toppings, &$flag_escape) {
    $pdata_block = NULL;
    $newline_char = NULL;
    if ($pdata) {
        $newline_char = kwartz_detect_newline_char($pdata);
        $converter = new KwartzConverter($pdata, $toppings);
        $pdata_block = $converter->convert();
    }
    
    // convert presentation logic code into block
    $plogic_block = NULL;
    if ($plogic) {
        $parser = new KwartzParser($plogic, $toppings);
        $plogic_block = $parser->parse();
    }
    
    // merge blocks and create a new block
    if (! ($pdata_block || $plogic_block)) {
        return NULL;
    }
    if ($pdata_block && $plogic_block) {
        $block = $pdata_block->merge($plogic_block);
    } else {
        $block = $pdata_block ? $pdata_block : $plogic_block;
    }
    
    // translate
    $translator = new KwartzPhpTranslator($block, $flag_escape, $toppings);
    $output = $translator->translate();
    
    // analyze
    $analyzer = new KwartzAnalyzer($block);
    $analyzer->analyze();
    $global_vars = $analyzer->global_vars();
    
    return array($output, array_keys($global_vars));
}


function create_method_definition(&$hash) {
    $method_name = $hash['method_name'];
    $method_body = $hash['method_body'];
    $method_args = $hash['method_args'];
    $global_vars = $hash['global_vars'];
    $class_name  = $hash['class_name'];
    $flag_escape = $hash['flag_escape'];

    $variables = $global_vars ? $global_vars : array();

    $s = '';
    if ($method_args) {
        $variables = preg_split('/,/', $method_args);
        $list  = array();
        $list2 = array();
        foreach ($variables as $var) {
            $list[] = '$' . $var;
            $list2[] = '&$' . $var;
        }
        $method_args  = join(', ', $list);
	$method_args2 = join(', ', $list2);
    }

    $var_decl = '';
    foreach ($variables as $var) {
        $var_decl .= "\t$" . $var . " = \$_args['" . $var . "'];\n";
    }
    $var_decl = rtrim($var_decl);
    
    $prefix = $class_name ? "{$class_name}::" : "";

    if (! $method_args) {
	$s = <<<END
		    function ${method_name}(\$_args) {
		${var_decl}
			ob_start();
			?>${method_body}<?php
			\$_s = ob_get_contents();
			ob_end_clean();
			return \$_s;
		    }

END;
    } else {
        $s = <<<END
		    function ${method_name}(\$_args) {
		${var_decl}
			return ${prefix}_${method_name}(${method_args});
		    }
		    function _${method_name}(${method_args2}) {
			ob_start();
			?>${method_body}<?php
			\$_s = ob_get_contents();
			ob_end_clean();
			return \$_s;
		    }

END;
    }
    if ($class_name) {
        $s = "class ${class_name} {\n" . $s . "}\n";
    }
    $s = "<?php\n" . preg_replace('/^\t\t/m', '', $s) . "?>";
    return $s;
}



function main($args) {
    $lang            = 'php';
    $plogic_filename = NULL;
    $module_name     = NULL;
    $method_name     = NULL;
    $method_args     = NULL;
    $flag_ob         = true;

    $command = basename(array_shift($args));
    try {
        $tuple    = parse_args($args, "hvse", "plmca", "i");
        $options  = $tuple[0];
        $toppings = $tuple[1];
    } catch (KwartzCommandOptionError $ex) {
        $msg = "{$command}: {$ex->getMessage()}\n";
        fwrite(STDERR, $msg);
        exit(1);
    }

    //echo "*** debug: args=", var_dump($args);
    //echo "*** debug: options=", var_dump($options);
    //echo "*** debug: toppings=", var_dump($toppings);
    //exit(0);

    if (array_key_exists('help', $toppings)) {
        $options['h'] = TRUE;
    }
    
    // command line options
    if (array_value('h', $options) || array_value('v', $options)) {
        if (array_value('v', $options)) {
            fwrite(STDERR, version());
        }
        if (array_value('h', $options)) {
            fwrite(STDERR, usage($command));
        }
        exit(0);
    }

    // options
    $class_name      = array_value('c', $options);
    $method_name     = array_value('m', $options);
    $method_args     = array_value('a', $options);
    $plogic_filename = array_value('p', $options);

    // filename
    $pdata_filename = $args[0];
    if (! $pdata_filename) {
        $msg = "presentation data file is not specified.\n";
        fwrite(STDERR, $msg);
        exit(0);
    }
    
    // echo "*** debug: pdata_filename='$pdata_filename'\n";
    // exit(0);

    // toppings
    if (array_value('s', $options) || array_value('e', $options)) {
        $toppings['escape'] = TRUE;
        $flag_escape = TRUE;
    }
    if ($val = array_value('include_path', $toppings)) {
        $toppings['include_path'] = preg_split('/,/', $val);
    }
    if ($val = array_value('load_path', $toppings)) {
        $toppings['load_path'] = preg_split('/,/', $val);
    }
    
    //echo "*** debug: toppings=", var_dump($toppings);
    //exit(0);

    // compile
    $pdata  = file_get_contents($pdata_filename);
    $plogic = '';
    if ($plogic_filename) {
        $plogic = file_get_contents($plogic_filename);
    }
    list($output, $global_vars) = compile($pdata, $plogic, $toppings, $flag_escape);
    //echo "*** debug: pdata=$pdata\n";
    //echo "*** debug: plogic=$plogic\n";
    //echo "*** debug: output=$output\n";
    //echo "*** debug: global_vars="; print_r($global_vars);
    //exit(0);

    // set values
    if (!$method_name) {
        $basename = preg_replace('/\..+/', '', basename($pdata_filename));
        $method_name = "expand_${basename}";
    }
    $method_body = $output;

    $hash = array(
        'method_name' => $method_name,
        'method_body' => $method_body,
        'method_args' => $method_args,
        'global_vars' => $global_vars,
        'class_name'  => $class_name,
        'flag_escape' => $flag_escape,
    );
    //echo "*** debug: hash="; print_r($hash);
    //exit(0);
    
    // print definition
    $definition = create_method_definition($hash);
    echo $definition;
}

main($argv);

?>