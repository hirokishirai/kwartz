.=title:	Kwartz-ruby 3.0 Reference Guide
.?lastupdate:	$Date$
.?version:	$Release$
.?stylesheet:	docstyle.css


.$ Preface	| preface*

This document{{(This document is generated automatically from unit-test data. Knuth had propsed integration of code and document.  I propose integration of test and document :-))}} is the reference manual of Kwartz-ruby 3.0.

Kwartz{{(Development of Kwartz had subsidized by Exploratory Software Project of {{<IPA (Information-Technology Promotion Agency Japan)|http://www.ipa.go.jp/about/english/index.html>}}.)}} is a template system which realized the concept 'Independence of Presentation Logic'.
It means that presentation logics are separated from both presentation data (typically HTML file) and business logic layer (typically main program).

If you are new to Kwartz, see {{<Users' Guide|users-guide.html>}} at first.



.$$ Table of Contents	      | toc*

.<<< reference.toc


[%

  def untabify(str, width=8)
    sb = ''
    str.scan(/(.*?)\t/m) do |s, |
      len = (n = s.rindex(?\n)) ? s.length - n - 1 : s.length
      sb << s << (" " * (width - len % width))
    end
    return $' ? (sb << $') : str
  end

  require 'yaml'

%]

.# --------------------------------------------------------------------------------


.$ Pesentation Logic	| plogic

Presentation logic format in Kwartz is similar to Cascading Style Sheet (CSS).
.* Presentation logic file is a set of ruleset.
.* Ruleset is a pair of selector and declarations.
.* Declaration is a pair of property and value.

.? Pseudo-EBNF syntax of presentation logic
.____________________
plogic       ::=  ruleset*
ruleset      ::=  selector '{' [ declaration ';' ]* '}'
selector     ::=  '#' name
declaration  ::=  property ':' value
property     ::=  'elem'   | 'Elem'   | 'ELEM'
               |  'stag'   | 'Stag'   | 'STAG'
	       |  'etag'   | 'Etag'   | 'ETAG'
	       |  'cont'   | 'Cont'   | 'CONT'
	       |  'value'  | 'Value'  | 'VALUE'
	       |  'attrs'  | 'Attrs'  | 'ATTRS'
	       |  'append' | 'Append' | 'APPEND'
	       |  'remove'
	       |  'logic'
.____________________

Notice that the tail semicolon of declaration is not omittable.


[%

  yamlfile = '../test/test-ruleset.yaml'
  
  str = File.read(yamlfile)
  str = untabify(str)
  context = YAML.load(str)

  context.each do |data|
    name     = data['name']
    title    = data['title']
    desc     = data['desc']
    pdata    = data['pdata']
    plogic   = data['plogic*']
    expected = data['expected*']
    postscript = data['postscript'] || ''

%]

.$$ [%= title %]	| property-[%= name %]

[%= desc %]

[%= postscript %]

[%
    #if data['common']
    #  list = [ ['Ruby, PHP, JSP, Perl'], 'eruby' ]
    #else
      list = [ ['Ruby', 'eruby'], ['PHP', 'php'], ['JSP', 'jstl'], ['Perl', 'eperl'] ]
    #end
    list.each do |title, lang|
      next unless plogic[lang]
 %]
.$$$ [%= title %]	| property-[%= name %]-[%= lang %]

.? presentation data (ex-[%= name %].pdata)
.--------------------
[%= pdata.chomp %]
.--------------------

.? presentation logic (ex-[%= name %].plogic)
.--------------------
[%= plogic[lang].chomp %]
.--------------------

.? compile
.====================
$ kwartz -l [%= lang %] -p ex-[%= name %].plogic ex-[%= name %].pdata
[%= expected[lang].chomp %]
.====================

[%
    end
%]

[%
  end
%]


.$$ {{,#DOCUMENT,}} selector and {{,begin:,}}, {{,end:,}} properties

Special selector {{,#DOCUMENT,}} represents entire of document.
Only the {{,begin:,}} and {{,end:,}} properties are available in {{,#DOCUMENT,}} selector.
The former adds statements in the beginning of the document and the latter adds statements in the end of the document.


.# --------------------------------------------------------------------------------


.$ Directives		| directives

Directives are commands to embed presentation logics into presentation data.
For example, {{,title="for item in @list",}} directive represents iteration of the element.

Directives are provided for '{{*choosability*}}'.
This is very important concept for Kwartz (and other products by kuwata-lab).
In Kwartz, you can separate presentation logics from presentation data, or 'mix' them.
It is the user or customer of Kwartz and not developer who determine which solution to adopt.
All Kwartz can do is to provide the both solution to users.

Notice that the notation of directives are different for each target language.
For example, iteration directive is {{,title="for item in list",}} in Ruby,
{{,title="foreach($list as $item)",}} in PHP.
See the {{,directive notation table,}} for PHP, Java, and Perl user.



[%

  yamlfile = '../test/test-directives.yaml'
  
  str = File.read(yamlfile)
  str = untabify(str)
  context = YAML.load(str)

  context.each do |data|
    name     = data['name']
    subject  = data['subject']
    desc     = data['desc']
    pdata    = data['pdata*']
    expected = data['expected*']
%]


.$$ [%= subject %]	| directive-[%= name %]

[%= desc %]

[%
    if data['common']
      list = [ ['Ruby, PHP, JSP, Perl', 'eruby'] ]
    else
      list = [ ['Ruby', 'eruby'], ['PHP', 'php'], ['JSP', 'jstl'], ['Perl', 'eperl'] ]
    end
    list.each do |title, lang|
      next unless pdata[lang]
 %]

.$$$ [%= title %]	| directive-[%= name %]-[%= lang %]

.? presentation data (ex-[%= name %].pdata)
.--------------------
[%= pdata[lang].chomp %]
.--------------------

.? compile
.====================
$ kwartz -l [%= lang %] ex-[%= name %].pdata
[%= expected[lang].chomp %]
.====================

[%
    end
%]


[%
  end
%]
